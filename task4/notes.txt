1. Способы векторизации:
  1.1 Асм вставки 
  1.2 Использование встроенных в компилятор функций
  1.3 Использование векторных расширений gcc
  1.4 Автоматическая векторизация компилятором
  1.5 Использование сторонних библиотек (BLAS LAPACK)



_mm_loadu_ps load unaligned позволяет загружать данные из произвольного адреса в памяти, даже если этот адрес не выровнен.
 Он принимает указатель на данные типа __m128 (вектор из 4 одинарной точности значений с плавающей запятой) и загружает их в регистр SSE.

Важно отметить, что при использовании _mm_loadu_ps может возникнуть некоторое снижение производительности по сравнению с использованием _mm_load_ps, когда данные выровнены. 
 ем не менее, в большинстве сценариев этот недостаток компенсируется гибкостью загрузки данных из произвольных адресов.

_ps означает "packed single-precision floating-point" (упакованные одинарной точности с плавающей запятой).
 Этот суффикс указывает, что инструкция работает с упакованными векторами чисел одинарной точности, которые хранятся в регистрах SSE. 
 Каждый регистр может содержать несколько значений (например, 4 значения типа float в регистре __m128). 4 f32

_ss означает "scalar single-precision floating-point" (скалярная одинарной точности с плавающей запятой). 1 f32
Этот суффикс указывает, что инструкция работает со скалярными (одиночными) значениями одинарной точности с плавающей запятой, а не с упакованными векторами. 
Эти инструкции применяются к одному значению в регистре.

Пример:

_mm_add_ps выполняет сложение для четырех значений float, хранящихся в двух регистрах __m128 (упакованный вектор).

_mm_add_ss выполняет сложение для одного значения float, хранящегося в одном регистре __m128 (скалярное значение).

Про регистры:

- MMX (multimedia extension) Векторное расширение MMX работает с             8рег по 64 в каждом 1 int64_t 2 int_32t 4 int_16t 8 int_8t
64-битными регистрами MM0-MM7, логически расположенными на
регистрах сопроцессора, и включает 57 новых команд для работы с ними. 64-
битные регистры логически могут представляться как одно 64-битное, два
32-битных, четыре 16-битных или восемь 8-битных упакованных целых
чисел.
     - Еще одна особенность технологии MMX – это целочисленная
арифметика с насыщением, используемая, например, при обработке графики.
В целочисленное арифметике с насыщением переполнение не является 
циклическим, как обычно, а вместо этого фиксируется минимальное или
максимальное значение

- 3DNOW! Это была первая технология, выполняющая потоковую обработку        в 1 mmx регистр можно засунуть 2f32
вещественных данных. Расширение работает с 64-битными регистрами
MMX, которые теперь представляются как два 32-битных вещественных
числа с одинарной точностью. Система команд расширена 21 новой
командой, среди которых появилась команда предвыборки данных в кэш L1. 

- SSE Это расширение работает с независимым блоком из восьми 128-битных    8рег по 128
регистров XMM0-XMM7. Каждый регистр XMM представляет собой четыре
упакованных 32-битных вещественных числа с одинарной точностью.
Команды блока XMM позволяют выполнять как векторные (над всеми
четырьмя значениями регистра), так и скалярные операции (только над
одним самым младшим значением). Кроме команд для работы с блоком
XMM в расширение SSE входят и дополнительные целочисленные команды
для работы с регистрами MMX, а также команды управления кэшированием.
В архитектуре x86-64 число регистров XMM было увеличено до 16-ти:
XMM0-XMM15.


- SSE2 позволяет работать с 128-битными регистрами XMM как с
парой упакованных 64-битных вещественных чисел двойной точности, а
также с упакованными целыми числами: 16 байт, 8 слов, 4 двойных (32-
битных) слова или 2 учетверенных (64-битных) слова. Соответственно,
введены новые команды вещественной арифметики двойной точности и
команды целочисленной арифметики: 128-разрядные для регистров XMM и
64-разрядные для регистров MMX. Ряд старых команд MMX распространили
и на XMM (в 128-битном варианте).

- Расширения SSE3, SSSE3, SSE4, ...
В последующих процессорах Intel и AMD происходит дальнейшее
расширение системы команд на регистрах MMX и XMM. Добавлены новые
команды для ускорения обработки видео, текстовых данных. Особенно
следует отметить появившуюся возможность горизонтальной работы с
регистрами (выполнение операций с элементами одного вектора).

-AVX В процессорах архитектуры Sandy Bridge от Intel и процессорах
архитектуры Bulldozer от AMD векторные расширения сделали следующий
большой шаг в развитии: появились новые векторные регистры YMM0-
YMM15 размером 256 бит. Существующие ранее регистры XMM стали
занимать младшую часть новых регистров. Среди особенностей расширения
AVX есть поддержка трехоперандных операций вида (c = a OP b), а также
менее строгие требования к выравниванию векторных данных в памяти.

Тип данных __m128 представляет собой 128-битный регистр, который используется для SIMD (Single Instruction, Multiple Data) операций с плавающей запятой в ассемблерных
    вставках или при программировании с использованием SIMD-инструкций, таких как SSE (Streaming SIMD Extensions) в архитектуре x86.


//ASM вставка в функцию умножения матриц использует SSE SIMD расширение
asm volatile (
                    "movss %1, %%xmm1\n\t"
                    "movss %2, %%xmm2\n\t"
                    "mulss %%xmm2, %%xmm1\n\t"
                    "movss %0, %%xmm0\n\t"
                    "addss %%xmm1, %%xmm0\n\t"
                    "movss %%xmm0, %0\n\t"
                    : "+m"(res->data[i * mx1->size + j])
                    : "m"(mx1->data[i * mx1->size + k]), "m"(mx2_t->data[j * mx2->size + k])
                    : "xmm0", "xmm1", "xmm2"
                );

"movss %1, %%xmm1\n\t": Загрузка значения из mx1 по адресу %1 в регистр %xmm1. %1 представляет собой операнд, переданный через вводные (input) операторы "m"(mx1->data[i * mx1->size + k]).

"movss %2, %%xmm2\n\t": Загрузка значения из mx2_t по адресу %2 в регистр %xmm2. %2 представляет собой операнд, переданный через вводные (input) операторы "m"(mx2_t->data[j * mx2->size + k]).

"mulss %%xmm2, %%xmm1\n\t": Умножение значений в регистрах %xmm1 и %xmm2 (результат в %xmm1). Используется инструкция mulss, которая выполняет умножение для значений одинарной точности с плавающей запятой.

"movss %0, %%xmm0\n\t": Загрузка текущего значения из res->data[i * mx1->size + j] по адресу %0 в регистр %xmm0. %0 представляет собой выходной (output) операнд, который будет обновлен после выполнения ассемблерной вставки.

"addss %%xmm1, %%xmm0\n\t": Сложение значений в регистрах %xmm1 и %xmm0 (результат в %xmm0). Используется инструкция addss, которая выполняет сложение для значений одинарной точности с плавающей запятой.

"movss %%xmm0, %0\n\t": Сохранение значения из регистра %xmm0 обратно в res->data[i * mx1->size + j] по адресу %0. %0 представляет собой выходной (output) операнд.

: "+m"(res->data[i * mx1->size + j]): Список выходных операндов. "+m" указывает, что res->data[i * mx1->size + j] используется как вход и выход.

: "m"(mx1->data[i * mx1->size + k]), "m"(mx2_t->data[j * mx2->size + k]): Список входных операндов. "m" указывает, что операнды должны быть загружены в регистры для использования в ассемблерном коде.

: "xmm0", "xmm1", "xmm2": Список регистров, которые используются в ассемблерной вставке. Это предостережение для компилятора, что регистры %xmm0, %xmm1, %xmm2 будут изменены в ходе выполнения ассемблерной вставки.

_mm_load_ps - 4 берет и загружает
-mm_loadu_ps - тож самое но не выровнен
-mm_load1_ps - 1 берет и 4 раза загружает

_mm_cvtss_f32 - это интринсик, который используется для преобразования одного значения из вектора с плавающей запятой в скаляр с плавающей запятой. 
В данном случае, он преобразует единственное значение из вектора _sum в скаляр float.
Крч младший 32f из вектора достает

_mm_storeu_ps - засунуть
_mm_loadu_ps - высунуть

m (Memory): Этот модификатор используется для операндов, которые представляют собой значения в памяти.
+m (Input and Output in Memory): Этот модификатор указывает, что операнд не только читается из памяти, но и записывается обратно в память.
//v3
cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasTrans, mx1->size, mx1->size, mx1->size, 1.0f, mx1->data, mx1->size,
                mx2->data, mx2->size, 0.0f, res->data, mx1->size);

C=1.0×A×B+0.0×C

CblasRowMajor: Указывает, что матрицы A, B и C хранятся в порядке по строкам (рядам).
CblasNoTrans: Не требуется транспонирование матрицы A.
CblasTrans: Требуется транспонирование матрицы B.
mx1->size, mx1->size, mx1->size: Размерности матриц A, B и C. Предполагается, что все три матрицы квадратные размерности mx1->size x mx1->size.
1.0f: Скаляр, умножаемый на матрицу A.
mx1->data: Указатель на данные матрицы A.
mx1->size: Шаг по строкам для матрицы A.
mx2->data: Указатель на данные матрицы B.
mx2->size: Шаг по строкам для матрицы B.
0.0f: Скаляр, умножаемый на матрицу C.
res->data: Указатель на данные матрицы C, куда будет записан результат.
mx1->size: Шаг по строкам для матрицы C


#inc - шаг
//void cblas_scopy(const int N, const float *X, const int incX, float *Y, const int incY); - копирует из одного вектора в другой
//void cblas_saxpy(const int N, const float a, const float *X, const int incX, float *Y, const int incY); //a * x + y
//void cblas_sscal(const int N, const float alpha, float *X, const int incX); //умножение вектора на скаляр //a * x


Внешний цикл i проходит по строкам первой матрицы (mx1).
Средний цикл j проходит по столбцам первой матрицы (mx1) и, соответственно, по строкам второй матрицы (mx2).
Внутренний цикл k проходит по столбцам второй матрицы (mx2).
Таким образом, на каждом шаге внутреннего цикла происходит умножение элементов из строки i первой матрицы на элементы из столбца k второй матрицы. 
Результат суммируется в соответствующую ячейку результирующей матрицы res.