fill_arr:
        pushq   %rbp //сохраняем rbp на вершину стека
        movq    %rsp, %rbp //устанавливаем базовый указатель стека rbp в текущее знчение rsp (создаем стековый фрейм для fill_arr)
        movq    %rdi, -24(%rbp) //перемещаем значение первого аргумента в локальную переменную
        movl    %esi, -28(%rbp) //перемещаем значение второго аргумента в локальную переменную
        movl    $0, -4(%rbp) //инициализируем локальную переменную счетчик нулем
        jmp     .L2 //безусловный переход к метке .L2 для начала выполнения цикла
.L3:
        movl    -4(%rbp), %eax //загружаем i в eax
        cltq                   //знаково расширяем eax до rax
        leaq    0(,%rax,4), %rdx //вычисляем адрес элемента в массиве который нужно заполнить путем умножения индекса на размер элемента
        movq    -24(%rbp), %rax //загружаем указатель на массив из локальной переменной в rax
        addq    %rax, %rdx //добавляем смещение к указателю на массив для получения адреса текущего элемента
        movl    -28(%rbp), %eax //загружаем значение которое нужно записать в текущий элемент в eax
        subl    -4(%rbp), %eax //вычитаем значение индекса из значения которое нужно записать
        movl    %eax, (%rdx) //записываем значение в текущий элемент массива
        addl    $1, -4(%rbp) //i++
.L2:
        movl    -4(%rbp), %eax //загружаем значение индекса в eax
        cmpl    -28(%rbp), %eax //сраниваем i с размером массива
        jl      .L3 //если i меньше размера массива идем в L3
        nop         //нет операции
        nop         //нет операции
        popq    %rbp //восстанавливаем значение базового указателя
        ret          //возвращаемся из процедуры
swap:
        pushq   %rbp  //сохраняем rbp на стеке
        movq    %rsp, %rbp //устанавливаем rbp в rsp создавая новый стековый фрейм функции
        movq    %rdi, -24(%rbp) //сохраняем первый аргумент функции в локальную переменную на стеке
        movq    %rsi, -32(%rbp) //сохраняем второй аргумент функции в локальную переменную на стеке
        movq    -24(%rbp), %rax //загружаем адрес первого элемента в rax
        movl    (%rax), %eax //загружаем значение первого элемента в eax
        movl    %eax, -4(%rbp) //сохраняем значение первого элемента в локальной переменной на стеке
        movq    -32(%rbp), %rax //загружаем адрес второго элемента в rax
        movl    (%rax), %edx //загружаем значение второго элемента в edx
        movq    -24(%rbp), %rax //загружаем адрес первого элемента в rax
        movl    %edx, (%rax) //сохраняем значение второго элемента в ячейку адресованную первым элементом
        movq    -32(%rbp), %rax //загружаем адрес второго элемента в rax
        movl    -4(%rbp), %edx //загружаем значение первого элемента из tmp
        movl    %edx, (%rax) //сохраняем значение первого элемента в ячейку адресованную вторым элементом
        nop                 //no operation
        popq    %rbp        //достаем rbp из стека
        ret //выходим из swap
bubble_sort:
        pushq   %rbp //сохраняем текущее значение указателя на стеке
        movq    %rsp, %rbp //устанавливаем указатель стека в начало текущей процедуры (создаем стековый фрейм для процедуры)
        subq    $32, %rsp //выделяем 32 байта на стеке для локальных переменных
        movq    %rdi, -24(%rbp) //сохраняем указатель на массив в локальную переменную на стеке
        movl    %esi, -28(%rbp) //сохраняем размер массива в локальной переменной на стеке
        movl    $0, -4(%rbp) //инициализируем счетчик внешнего цикла на стеке нулем
        jmp     .L6 //переходим к началу внешнего цикла
.L10:
        movl    $0, -8(%rbp) //инициализируем счетчик внутреннего цикла j нулем
        jmp     .L7 //идем к проверке внутреннего цикла
.L9:
        movl    -8(%rbp), %eax //загружаем j в eax
        cltq                   //знаково расширяем eax до rax
        leaq    0(,%rax,4), %rdx //вычисляем смещение j * 4 и сохраняем в rdx
        movq    -24(%rbp), %rax //загружаем указатель на массив в rax
        addq    %rdx, %rax //добавляем смещение к указателю на массив, чтобы получить адрес текущего элемента
        movl    (%rax), %edx //загружаем значение этого элемента в edx
        movl    -8(%rbp), %eax //загружаем счетчик j в eax
        cltq                   //знаково расширяем eax до rax
        addq    $1, %rax       //j++
        leaq    0(,%rax,4), %rcx //вычисляем смещение (j+1) * 4 и сохраняем в rcx
        movq    -24(%rbp), %rax //загружаем указатель на массив в rax
        addq    %rcx, %rax //добавляем смещение к указателю на массив чтобы получить адрес слледущего элемента
        movl    (%rax), %eax //загружаем значение след элемента в eax
        cmpl    %eax, %edx //сравниваем текущий и следущий элемент 
        jle     .L8 //если предыдущий <= следущему идем в след итерацию внутреннего цикла
        movl    -8(%rbp), %eax //загружаем значение j в eax
        cltq                   //знаково расширяем eax до rax
        addq    $1, %rax //j+1
        leaq    0(,%rax,4), %rdx //вычисляем смещение (j+1) * 4 и сохраняем в rdx
        movq    -24(%rbp), %rax //загружаем указатель на массив в rax
        addq    %rax, %rdx //добавляем смещение к указателю на массив чтобы получить адрес следущего элемента
        movl    -8(%rbp), %eax //загружаем j в eax
        cltq                   //знаково расширяем eax до rax
        leaq    0(,%rax,4), %rcx //вычисляем смещение j * 4 и сохраняем в rcx
        movq    -24(%rbp), %rax //загружаем указатель на массив в rax
        addq    %rcx, %rax //добавляем смещение к указателю чтобы получить адрес текущего элемента
        movq    %rdx, %rsi //передаем адрес следущего элемента вторым аргументом в swap
        movq    %rax, %rdi //передаем адрес текущего элемента первым аргументом в swap
        call    swap     //зовем своп
.L8:
        addl    $1, -8(%rbp) //j++
.L7:
        movl    -28(%rbp), %eax //загружаем значение второго аргумента функции длину в eax
        subl    -4(%rbp), %eax //вычитаем значение i из длины масива
        subl    $1, %eax //вычитаем 1
        cmpl    %eax, -8(%rbp) //сравниваем значение счетчика внутреннего цикла с длинной массива
        jl      .L9 // если j < len - 1 прыгаем в L9
        addl    $1, -4(%rbp) //i++
.L6:
        movl    -28(%rbp), %eax //загружаем значение второго аргумента (длина массива) в eax
        subl    $1, %eax //вычитаем 1
        cmpl    %eax, -4(%rbp) //сравниваем счетчик внешнего цикла с длиной - 1
        jl      .L10 //если меньше переходим к итерации
        nop      
        nop
        leave   //восстанавливаем указатель стека и базовый указатель
        ret     //возвращаемся из процедуры
main:
        pushq   %rbp //сохраняем значение регистра rbp на стеке
        movq    %rsp, %rbp //устанавливаем регистр rbp в текущее значение указателя rsp, создавая новый стековый фрейм дял текущей функции
        pushq   %rbx //сохраняем значение rbx на стеке rsp = rbp - 8
        subq    $56, %rsp //распределяем место на стеке для локальных переменных rsp = rbp - 64
        movl    %edi, -52(%rbp) //перемещаем значение первого аргумента argc который передается в edi в локальную переменную на стеке
        movq    %rsi, -64(%rbp) //перемещаем значение второго аргумента argv в локальную переменную на стеке
        movq    %rsp, %rax //копируем значение указателя стека в rax
        movq    %rax, %rbx //копируем rax в rbx
        movq    -64(%rbp), %rax //загружаем указатель на нулевой элемент массива argv в rax
        addq    $8, %rax //перемещаем указатель на следущий элемент массива
        movq    (%rax), %rax //загружаем в rax значение первого элемента массива argv
        movq    %rax, %rdi //перемещаем это значение в rdi для передачи его функции atoi
        call    atoi //вызываем atoi
        movl    %eax, -20(%rbp) //сохраняем результат atoi на стеке
        movl    -20(%rbp), %eax //загружаем сохраненное N обратно в eax??
        movslq  %eax, %rdx //расширяем 32 битное значение eax до 64 битного rdx
        subq    $1, %rdx //вычитаем 1 из значения в rdx
        movq    %rdx, -32(%rbp) //сохраняем результат вычитания в другой локальной переменной на стеке
        cltq                    //знаково расширяем 32 битное значение в eax до 64 бит в rdx
        leaq    0(,%rax,4), %rdx //вычисляем смещение в массиве, умножая значение в rax на 4
        movl    $16, %eax //устанавливаем значение 16 в eax
        subq    $1, %rax //вычитаем 1 из значения в rax
        addq    %rdx, %rax //добавляем значение rdx в rax
        movl    $16, %ecx //устанавливаем значение 16 в ecx
        movl    $0, %edx //устанавливаем значение 0 в edx
        divq    %rcx //деление rax на rcx (16)
        imulq   $16, %rax, %rax //умножаем результат деления на 16
        subq    %rax, %rsp //вычитаем результат из указателя стека
        movq    %rsp, %rax //копируем значение указателя стека rsp в регистр rax
        addq    $3, %rax //добавляем 3 для выравнивания адреса на границу 16 байт
        shrq    $2, %rax //делим на 4 чтобы получить количество интов в масиве
        salq    $2, %rax //умножаем на чтобы получить количество байт на массив
        movq    %rax, -40(%rbp) //сохраняем размер массива в локальной переменной на стеке
        movl    -20(%rbp), %edx //загружаем значение N в edx
        movq    -40(%rbp), %rax //загружаем размер массива в rax
        movl    %edx, %esi //передаем размер массива в качестве второго аргумента
        movq    %rax, %rdi //передаем указатель на массив в качестве первого аргумента
        call    fill_arr //зовем fill_arr
        movl    -20(%rbp), %edx //загружаем значение сохранненого int в edx
        movq    -40(%rbp), %rax //загружаем указатель на массив в rax 
        movl    %edx, %esi //передаем размер массива вторым аргументом
        movq    %rax, %rdi //передаем указатель на массив первым аргументом
        call    bubble_sort //зовем bubble_sort
        movl    $0, %eax   //устанавливаем 0 в eax (возвращаемое значение main)
        movq    %rbx, %rsp //восстанавлив значение указателя стека до предыдущего состояния (перед вызовом main)
        movq    -8(%rbp), %rbx //восстанавливаем rbx
        leave   //Очищаем фрейм стека, восстанавливая предыдущее значение указателя стека (%rsp) и регистра %rbp.
        ret   //выходим из main
